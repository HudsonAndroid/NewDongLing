package com.hudson.donglingmusic.common.Utils.asyncUtils;import android.support.annotation.NonNull;import com.hudson.donglingmusic.common.Utils.asyncUtils.pool.PoolType;import java.util.Set;import java.util.concurrent.CopyOnWriteArraySet;import rx.Observable;import rx.Observer;import rx.Subscriber;import rx.android.schedulers.AndroidSchedulers;import rx.schedulers.Schedulers;public class AsyncTask<T> {    private IDoInBackground<T> mDoInBackground;    private Set<IDoOnSuccess<T>> mDoOnSuccessSet = new CopyOnWriteArraySet<>();    private Set<IDoOnFail> mDoOnFailSet = new CopyOnWriteArraySet<>();    private Set<IDoInBackgroundNext<T>> mBackgroundNextSet = new CopyOnWriteArraySet<>();    private T mData;    private Throwable mError;    protected boolean mIsRunning = false;    private boolean mIsAcceptNullReturn = false;    private boolean mForbidAutoClear = false;    private AsyncTask mBefore;    private ITransfer<Object,T> mTransfer;    private PoolType mPoolType = PoolType.NetType;    @SuppressWarnings("unchecked")    private <E> AsyncTask(AsyncTask before, ITransfer<E, T> pTransfer){        mBefore = before;        mTransfer = (ITransfer<Object, T>) pTransfer;    }    public AsyncTask(){}    public AsyncTask<T> doInBackground(IDoInBackground<T> doInBackground) {        mDoInBackground = doInBackground;        return this;    }    public AsyncTask<T> doOnSuccess(IDoOnSuccess<T> doOnSuccess) {        if (doOnSuccess != null) {            if (mData != null) {                doOnSuccess.onSuccess(mData);            }else {                mDoOnSuccessSet.add(doOnSuccess);            }        }        return this;    }    public AsyncTask<T> doOnFail(IDoOnFail doOnFail) {        if (doOnFail != null) {            if (mError != null) {                doOnFail.onFail(mError);            }else {                mDoOnFailSet.add(doOnFail);            }        }        return this;    }    public AsyncTask<T> doInBackgroundNext(IDoInBackgroundNext<T> next) {        if (next != null) {            mBackgroundNextSet.add(next);        }        return this;    }    public <E> AsyncTask<E> transfer(@NonNull final ITransfer<T,E> pTransfer){        return new AsyncTask<>(this,pTransfer);    }    public void execute() {        if (mIsRunning) {            return;        }        mIsRunning = true;        if (mDoOnSuccessSet == null) {            throw new IllegalArgumentException("do on success can't be null");        }        Observable.create(new Observable.OnSubscribe<T>() {            @Override            public void call(Subscriber<? super T> pSubscriber) {                try {                    T t = doBackgroundTask();                    pSubscriber.onNext(t);                } catch (Exception pE) {                    pE.printStackTrace();                    pSubscriber.onError(pE);                } finally {                    pSubscriber.onCompleted();                }            }        }).subscribeOn(Schedulers.from(mPoolType.getPool()))                .observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<T>() {            @Override            public void onCompleted() {                mIsRunning = false;                if(!mForbidAutoClear){                    clear();                }            }            @Override            public void onError(Throwable e) {                mIsRunning = false;                mError = e;                for (IDoOnFail onFail : mDoOnFailSet) {                    onFail.onFail(e);                }                if(!mForbidAutoClear){                    clear();                }            }            @Override            public void onNext(T t) {                mIsRunning = false;                mData = t;                for (IDoOnSuccess<T> onSuccess : mDoOnSuccessSet) {                    onSuccess.onSuccess(t);                }                if(!mForbidAutoClear){                    clear();                }            }        });    }    /**     * 通常情况下，你不需要回调该方法     */    public void clear(){        mDoOnFailSet.clear();        mDoOnSuccessSet.clear();        mBackgroundNextSet.clear();        mDoInBackground = null;    }    private T doBackgroundTask(){        T t;        if (mBefore != null) {            Object object = mBefore.doBackgroundTask();            if (object == null) {                throw new AsyncException("result before transfer can't be null");            }            t = mTransfer.doTransfer(object);        }else {            if (mDoInBackground == null) {                throw new IllegalArgumentException("do in background can't be null");            }            t = mDoInBackground.run();        }        if (!mIsAcceptNullReturn && t == null) {            throw new AsyncException("do in background return null");        }        for (IDoInBackgroundNext<T> next : mBackgroundNextSet) {            next.run(t);            mBackgroundNextSet.remove(next);        }        return t;    }    public static <E> AsyncTask<E> newTask(Class<E> pTClass){        return new AsyncTask<>();    }    public static AsyncTask<Object> newTask(){        return new AsyncTask<>();    }    public AsyncTask<T> acceptNullReturn(){        mIsAcceptNullReturn = true;        return this;    }    public AsyncTask<T> forbidAutoClear(){        mForbidAutoClear = true;        return this;    }    /**     * you needn't call this,task use net type default.     * @return     */    public AsyncTask<T> useNetThreadPool(){        mPoolType = PoolType.NetType;        return this;    }    public AsyncTask<T> useDbThreadPool(){        mPoolType = PoolType.DbType;        return this;    }    public MergableTask merge(AsyncTask pTask){        MergableTask task = new MergableTask(this);        task.merge(pTask);        return task;    }}